// ============================================================================
// File: Lib.Db.TvpGen/TvpAccessorGenerator.cs
// Role: [TvpRow] 특성이 선언된 DTO를 감지하여,
//       고성능 TVP 접근자(TvpAccessors<T>) 등록 코드를 자동 생성하는 Source Generator
//
// ───────────────────────────────────────────────────────────────────────────
// ✅ 설계/정책 요약 (ResultAccessorGenerator 스타일 정렬 + CRITICAL-2 반영)
// ---------------------------------------------------------------------------
// 1) “토큰 계약” 유지(스냅샷 테스트 안정성)
//    - 생성 파일 헤더 3줄 고정:
//      ① // <auto-generated/>
//      ② // TVPGEN:TVP:TRACK5 (또는 동일 토큰)
//      ③ // TVPGEN:ALGO_VERSION:... (또는 동일 토큰)
//
// 2) Extreme Runtime (TVP 런타임 최적화)
//    - PropertyInfo 슬롯 채우기: (소규모) else-if / (대규모) FNV-1a + switch
//    - Row 핫패스: buffers[] → Typed ColumnCache(1회 캐스팅) 후 Add만 호출
//    - PropertyInfo 수집: ArrayPool 기반(상속 계층 포함)
//
// 3) 완전 수식 타입; FullyQualified 강제
//    - 생성 코드에서 타입 문자열은 “항상” FullyQualifiedFormat 사용
//    - type.Name / ToString() / 심볼 직접 보간으로 제네릭/중첩/네임스페이스 깨짐 방지
// ============================================================================

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lib.Db.TvpGen;

#region TVP 소스 제너레이터

/// <summary>
/// <para>
/// <b>[TvpRow]</b> 특성이 선언된 DTO를 감지하여,
/// 고성능 TVP 접근자(<c>TvpAccessors&lt;T&gt;</c>) 등록 코드를 자동 생성합니다.
/// </para>
/// <para>
/// ✅ <b>스냅샷 토큰(고정 계약)</b>
/// <list type="bullet">
/// <item><description>생성 파일 헤더에 <c>// &lt;auto-generated/&gt;</c> + 토큰 2줄(총 3줄)을 반드시 유지합니다.</description></item>
/// <item><description>테스트는 구현 디테일 대신 “토큰 계약”을 통해 Track/Algo 변경 여부만 검증합니다.</description></item>
/// </list>
/// </para>
/// <para>
/// ✅ <b>Track 4 (Extreme Runtime) 최적화 요약</b>
/// <list type="number">
/// <item><description>
/// <b>PropertyInfo 슬롯 채우기 무할당 하이브리드</b>:
/// 소규모는 <b>else-if 체인</b>, 대규모는 <b>결정론적 해시(FNV-1a) + switch</b>로 “1회 스캔”에서 슬롯을 채웁니다.
/// </description></item>
/// <item><description>
/// <b>Row 핫패스: 반복 캐스팅 제거</b>:
/// <c>buffers[]</c> 배열을 키로 <b>Typed ColumnCache</b>를 생성(1회 캐스팅)하고,
/// 이후 행 루프에서는 캐스팅 없이 Add만 호출합니다.
/// </description></item>
/// <item><description>
/// <b>ArrayPool 기반 PropertyInfo 수집</b>:
/// 상속 계층 포함 property 수집 시 List/재할당을 줄이고 ArrayPool 기반으로 수집합니다.
/// </description></item>
/// </list>
/// </para>
/// <para>
/// ✅ <b>CRITICAL-2(완전 수식 타입)</b>
/// <list type="bullet">
/// <item><description>생성 코드의 제네릭 타입 인수/typeof/캐스팅 등 타입 표기는 <see cref="SymbolDisplayFormat.FullyQualifiedFormat"/>으로 고정합니다.</description></item>
/// <item><description>중첩 타입/제네릭/using 변화에 영향을 받지 않는 “컴파일 안정성”을 보장합니다.</description></item>
/// </list>
/// </para>
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class TvpAccessorGenerator : IIncrementalGenerator
{
    #region 상수

    /// <summary>
    /// [TvpRow] 특성의 메타데이터 전체 이름
    /// </summary>
    private const string AttributeMetadataName = "Lib.Db.Contracts.Models.TvpRowAttribute";

    /// <summary>
    /// Track 4 하이브리드 라우팅 임계값
    /// <para>이 값 이하: else-if / 초과: FNV-1a + switch</para>
    /// </summary>
    private const int SmallMemberThreshold = 12;

    #endregion

    #region 진단 메시지

    // ⚠️ ID는 테스트 계약일 가능성이 높으므로 “변경 금지”를 전제로 유지합니다.

    private static readonly DiagnosticDescriptor s_genericNotSupported = new(
        id: "TVP001",
        title: "제네릭 타입 지원 불가",
        messageFormat: "TVP DTO '{0}'은(는) 제네릭 타입일 수 없습니다.",
        category: "Design",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor s_inaccessibleType = new(
        id: "TVP002",
        title: "접근 불가능한 타입",
        messageFormat: "TVP DTO '{0}' 또는 상위 타입이 private/protected로 선언되어 생성 코드에서 접근할 수 없습니다.",
        category: "Design",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor s_duplicateProperty = new(
        id: "TVP003",
        title: "중복된 속성 이름",
        messageFormat: "TVP DTO '{0}'에 속성명 '{1}'이(가) 중복되었습니다.",
        category: "Design",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor s_unsupportedType = new(
        id: "TVP004",
        title: "지원되지 않는 속성 타입",
        messageFormat: "속성 '{0}'의 타입 '{1}'은(는) TVP에서 지원되지 않습니다.",
        category: "Design",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor s_noProcessableProperties = new(
        id: "TVP005",
        title: "처리 가능한 속성 없음",
        messageFormat: "TVP DTO '{0}'에 매핑 가능한 Public 속성이 없습니다.",
        category: "Design",
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    #endregion

    #region 초기화

    /// <summary>
    /// 증분 파이프라인을 구성합니다.
    /// <para>특성 기반 후보 타입을 수집하고, 최종적으로 타입별 등록 코드를 생성합니다.</para>
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeMetadataName,
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (ctx, _) => (INamedTypeSymbol)ctx.TargetSymbol)
            .WithComparer(SymbolEqualityComparer.Default);

        context.RegisterSourceOutput(
            candidates.Collect(),
            static (spc, types) => Execute(spc, types));
    }

    #endregion

    #region 소스 생성 실행

    /// <summary>
    /// 후보 타입들에 대해 검증 후, 타입별 TVP 레지스트리 코드를 생성하여 출력합니다.
    /// </summary>
    private static void Execute(SourceProductionContext spc, ImmutableArray<INamedTypeSymbol> types)
    {
        if (types.IsDefaultOrEmpty)
            return;

        var seen = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var t in types)
        {
            spc.CancellationToken.ThrowIfCancellationRequested();

            if (t is null || !seen.Add(t))
                continue;

            if (!ValidateType(spc, t, out var props))
                continue;

            // ✅ TvpRow 옵션 읽기 (TypeName + UseDatetime2)
            var (sqlTypeName, useDatetime2) = TryGetTvpRowOptions(t);

            var code = GenerateRegistrationCode(t, props, sqlTypeName, useDatetime2);
            if (string.IsNullOrWhiteSpace(code))
                continue;

            spc.AddSource(
                BuildSafeHintName(t, "_TvpRegistry.g.cs"),
                SourceText.From(code, Encoding.UTF8));
        }
    }

    #endregion

    #region 검증

    /// <summary>
    /// 생성 가능한 타입인지 검증합니다.
    /// <para>제네릭/접근성/속성 중복/지원 타입 여부를 체크합니다.</para>
    /// </summary>
    private static bool ValidateType(
        SourceProductionContext spc,
        INamedTypeSymbol type,
        out List<IPropertySymbol> props)
    {
        props = new List<IPropertySymbol>(capacity: 32);

        // 1) 제네릭 금지
        if (type.IsGenericType)
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                s_genericNotSupported,
                type.Locations.FirstOrDefault(),
                type.Name));
            return false;
        }

        // 2) 접근성(중첩 포함)
        if (!IsAccessibleFromGeneratedCode(type))
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                s_inaccessibleType,
                type.Locations.FirstOrDefault(),
                type.Name));
            return false;
        }

        // 3) 처리 가능한 속성 수집
        props = GetProcessableProperties(type);

        if (props.Count == 0)
        {
            // 기존 로직 유지: warning이지만 false 반환(생성 자체는 하지 않음)
            spc.ReportDiagnostic(Diagnostic.Create(
                s_noProcessableProperties,
                type.Locations.FirstOrDefault(),
                type.Name));
            return false;
        }

        // 4) 중복 속성명 + 지원 타입 검사
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var p in props)
        {
            if (!seen.Add(p.Name))
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    s_duplicateProperty,
                    p.Locations.FirstOrDefault(),
                    type.Name,
                    p.Name));
                return false;
            }

            var sqlType = GetSqlTypeFromSymbol(p.Type);
            if (sqlType == "Variant")
            {
                // CRITICAL-2: 진단 메시지에도 가능한 한 완전 수식 타입으로 정보 제공(가독성/정확성)
                var typeDisplay = p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                spc.ReportDiagnostic(Diagnostic.Create(
                    s_unsupportedType,
                    p.Locations.FirstOrDefault(),
                    p.Name,
                    typeDisplay));
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// 생성 코드(동일 어셈블리/네임스페이스)에서 접근 가능한지 검사합니다.
    /// <para>중첩 타입의 ContainingType 체인까지 검사합니다.</para>
    /// </summary>
    private static bool IsAccessibleFromGeneratedCode(INamedTypeSymbol type)
    {
        var cur = type;

        while (cur is not null)
        {
            if (cur.DeclaredAccessibility is Accessibility.Private or Accessibility.Protected)
                return false;

            cur = cur.ContainingType;
        }

        return true;
    }

    #endregion

    #region 코드 생성

    /// <summary>
    /// 타입별 TVP Accessors 등록 코드를 생성합니다.
    /// <para>
    /// ✅ 생성 파일 헤더에는 반드시 다음 4줄을 유지합니다:
    /// <c>// &lt;auto-generated/&gt;</c>, <c>// TVPGEN:TVP:TRACK5</c>, <c>// TVPGEN:ALGO:...</c>, <c>// TVPGEN:DATETIME_TYPE:...</c>
    /// </para>
    /// <para>
    /// ✅ CRITICAL-2:
    /// 생성 코드의 타입 표기는 모두 FullyQualifiedFormat으로 고정합니다.
    /// </para>
    /// </summary>
    private static string GenerateRegistrationCode(
        INamedTypeSymbol type,
        List<IPropertySymbol> props,
        string? sqlTypeName,
        bool useDatetime2)
    {
        // ✅ CRITICAL-2: 완전 수식 타입 고정
        var fullTypeName = ToFullyQualifiedTypeName(type);

        // 생성 코드는 공용 네임스페이스에 배치(기존 정책 유지)
        var namespaceName = "Lib.Db.Generated";
        var suffix = GetUniqueSuffix(type);
        var registryClassName = $"TvpRegistry_{suffix}";
        var validatorClassName = $"StaticValidator_{suffix}";
        var cacheClassName = $"__ColumnCache_{suffix}";

        var sb = new StringBuilder(128 * 1024);

        // ✅ 헤더 + 스냅샷 토큰(고정 계약): "4줄 유지"
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// " + TvpGenFeatureTokens.TvpTrack5);
        sb.AppendLine("// " + TvpGenFeatureTokens.AlgoVersion);
        sb.AppendLine("// " + TvpGenFeatureTokens.GetDateTimeToken(useDatetime2));  // ✅ NEW
        sb.AppendLine("#nullable enable");

        #region Using 문 생성

        // NOTE:
        // - 생성 코드의 using은 “컴파일 가능성 + 최소 의존성”을 만족하는 선에서 유지합니다.
        // - 여기서도 타입 표기 자체는 FullyQualifiedFormat이므로 using 변화에 비교적 둔감합니다.
        string[] usings =
        [
            "using System;",
            "using System.Buffers;",
            "using System.Collections.Generic;",
            "using System.Collections.Frozen;",
            "using System.Data;",
            "using System.Reflection;",
            "using System.Runtime.CompilerServices;",
            "using Lib.Db.Execution.Tvp;",
            "using Lib.Db.Contracts.Models;",
            "using Lib.Db.Contracts.Schema;"
        ];

        foreach (var u in usings)
            sb.AppendLine(u);

        #endregion

        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {type.Name} 타입을 위한 자동 생성 TVP 레지스트리(Extreme Runtime)입니다.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]");
        sb.AppendLine($"    internal static class {registryClassName}");
        sb.AppendLine("    {");
        sb.AppendLine($"        private const int __SmallThreshold = {SmallMemberThreshold};");
        sb.AppendLine();

        // 결정론적 해시(FNV-1a)
        sb.AppendLine("        #region [내부 해시] 결정론적 이름 해시(FNV-1a, ASCII IgnoreCase)");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        sb.AppendLine("        private static uint __HashName(string s)");
        sb.AppendLine("        {");
        sb.AppendLine("            unchecked");
        sb.AppendLine("            {");
        sb.AppendLine("                const uint offset = 2166136261u;");
        sb.AppendLine("                const uint prime = 16777619u;");
        sb.AppendLine("                uint h = offset;");
        sb.AppendLine("                for (int i = 0; i < s.Length; i++)");
        sb.AppendLine("                {");
        sb.AppendLine("                    char c = s[i];");
        sb.AppendLine("                    if ((uint)(c - 'A') <= 25u) c = (char)(c | 0x20);");
        sb.AppendLine("                    h ^= c;");
        sb.AppendLine("                    h *= prime;");
        sb.AppendLine("                }");
        sb.AppendLine("                return h;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("        #endregion");
        sb.AppendLine();

        // Buffer 캐시(핫패스)
        sb.AppendLine("        #region [핫패스 캐시] buffers[] -> Typed ColumnCache (반복 캐스팅 제거)");
        sb.AppendLine($"        private static readonly ConditionalWeakTable<object[], {cacheClassName}> __bufferCache = new();");
        sb.AppendLine();

        sb.AppendLine($"        private sealed class {cacheClassName}");
        sb.AppendLine("        {");
        for (int i = 0; i < props.Count; i++)
        {
            // ✅ CRITICAL-2: ITvpColumn<T>의 T도 완전 수식 타입 고정
            var tName = ToFullyQualifiedTypeName(props[i].Type);
            sb.AppendLine($"            public readonly ITvpColumn<{tName}> C{i};");
        }

        sb.AppendLine();
        sb.AppendLine($"            public {cacheClassName}(object[] buffers)");
        sb.AppendLine("            {");
        for (int i = 0; i < props.Count; i++)
        {
            var tName = ToFullyQualifiedTypeName(props[i].Type);
            sb.AppendLine($"                C{i} = (ITvpColumn<{tName}>)buffers[{i}];");
        }
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        sb.AppendLine($"        private static void __AddRow({fullTypeName} dto, object[] buffers)");
        sb.AppendLine("        {");
        sb.AppendLine($"            var cache = __bufferCache.GetValue(buffers, static b => new {cacheClassName}(b));");
        for (int i = 0; i < props.Count; i++)
        {
            sb.AppendLine($"            cache.C{i}.Add(dto.{props[i].Name});");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        #endregion");
        sb.AppendLine();

        // ModuleInitializer
        sb.AppendLine("        /// <summary>모듈 로딩 시 자동 등록합니다.</summary>");
        sb.AppendLine("        [ModuleInitializer]");
        sb.AppendLine("        internal static void Init()");
        sb.AppendLine("        {");
        sb.AppendLine("            // 1. (Legacy) Accessor Registry (if needed / existing)");
        sb.AppendLine("            // TvpAccessorRegistry.Register(CreateAccessors()); ");
        sb.AppendLine("");
        sb.AppendLine("            // 2. Lib.Db Runtime Factory 등록 (Fast Binder)");
        sb.AppendLine("            Lib.Db.Execution.Binding.TvpFactoryRegistry.Register(");
        sb.AppendLine($"                typeof(global::System.Collections.Generic.IEnumerable<{fullTypeName}>),");
        sb.AppendLine($"                static obj => Lib.Db.Execution.Binding.DbBinder.ToDataReader((global::System.Collections.Generic.IEnumerable<{fullTypeName}>)obj),");
        sb.AppendLine($"                {(sqlTypeName is null ? "null" : $"\"{sqlTypeName}\"")}");
        sb.AppendLine("            );");
        sb.AppendLine("        }");
        sb.AppendLine();

        // 소규모 switch 라우팅(메타/디버그 편의)
        sb.AppendLine("        #region [소규모 Accessor] switch 라우팅(코드 크기↑, 런타임 미세 최적화)");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        sb.AppendLine($"        private static object? __GetTypedByOrdinal(in {fullTypeName} dto, int ordinal)");
        sb.AppendLine("        {");
        sb.AppendLine("            return ordinal switch");
        sb.AppendLine("            {");
        for (int i = 0; i < props.Count; i++)
            sb.AppendLine($"                {i} => dto.{props[i].Name},");
        sb.AppendLine("                _ => null");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        sb.AppendLine("        private static object? __GetObjectByOrdinal(object obj, int ordinal)");
        sb.AppendLine("        {");
        sb.AppendLine($"            var dto = ({fullTypeName})obj;");
        sb.AppendLine("            return __GetTypedByOrdinal(in dto, ordinal);");
        sb.AppendLine("        }");
        sb.AppendLine("        #endregion");
        sb.AppendLine();

        // CreateAccessors
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// 런타임 메타데이터(PropertyInfo) 및 접근자/검증기를 구성하여 반환합니다.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        private static TvpAccessors<{fullTypeName}> CreateAccessors()");
        sb.AppendLine("        {");
        sb.AppendLine("            // ------------------------------------------------------------");
        sb.AppendLine("            // 1) PropertyInfo 수집/슬롯 채우기 (Track 4 Extreme)");
        sb.AppendLine("            //    - 소규모: else-if 체인");
        sb.AppendLine("            //    - 대규모: 해시(FNV-1a) + switch (Dictionary 제거)");
        sb.AppendLine("            // ------------------------------------------------------------");
        sb.AppendLine($"            const int __Expected = {props.Count};");
        sb.AppendLine($"            var __all = GetAllInstancePropertiesPooled(typeof({fullTypeName}));");
        sb.AppendLine("            var __props = new PropertyInfo[__Expected];");
        sb.AppendLine("            int __remaining = __Expected;");
        sb.AppendLine();
        sb.AppendLine("            if (__Expected <= __SmallThreshold)");
        sb.AppendLine("            {");
        sb.AppendLine("                for (int i = 0; i < __all.Length; i++)");
        sb.AppendLine("                {");
        sb.AppendLine("                    var pi = __all[i];");
        sb.AppendLine("                    var n = pi.Name;");
        for (int i = 0; i < props.Count; i++)
        {
            var head = (i == 0) ? "                    if" : "                    else if";
            sb.AppendLine($"{head} (__props[{i}] is null && string.Equals(n, \"{props[i].Name}\", StringComparison.OrdinalIgnoreCase))");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        __props[{i}] = pi;");
            sb.AppendLine("                        if (--__remaining == 0) break;");
            sb.AppendLine("                    }");
        }
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine("                for (int i = 0; i < __all.Length; i++)");
        sb.AppendLine("                {");
        sb.AppendLine("                    var pi = __all[i];");
        sb.AppendLine("                    var n = pi.Name;");
        sb.AppendLine("                    uint h = __HashName(n);");
        sb.AppendLine("                    switch (h)");
        sb.AppendLine("                    {");
        for (int i = 0; i < props.Count; i++)
        {
            var p = props[i];
            uint hash = HashAsciiIgnoreCaseFnv1a(p.Name);
            sb.AppendLine($"                        case 0x{hash:X8}u: // {p.Name}");
            sb.AppendLine($"                            if (__props[{i}] is null && string.Equals(n, \"{p.Name}\", StringComparison.OrdinalIgnoreCase))");
            sb.AppendLine("                            {");
            sb.AppendLine($"                                __props[{i}] = pi;");
            sb.AppendLine("                                if (--__remaining == 0) goto __done;");
            sb.AppendLine("                            }");
            sb.AppendLine("                            break;");
        }
        sb.AppendLine("                        default: break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            __done:;");
        sb.AppendLine();

        for (int i = 0; i < props.Count; i++)
        {
            sb.AppendLine($"            if (__props[{i}] is null) ThrowMissingProperty(typeof({fullTypeName}), \"{props[i].Name}\");");
        }

        sb.AppendLine();
        sb.AppendLine("            PropertyInfo[] propsInfo = __props;");

        // OrdinalMap
        sb.AppendLine();
        sb.AppendLine("            // 2) OrdinalMap");
        sb.AppendLine("            var ordinal = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)");
        sb.AppendLine("            {");
        for (int i = 0; i < props.Count; i++)
            sb.AppendLine($"                [\"{props[i].Name}\"] = {i},");
        sb.AppendLine("            }.ToFrozenDictionary(StringComparer.OrdinalIgnoreCase);");

        // Accessors 하이브리드
        sb.AppendLine();
        sb.AppendLine("            // 3) Accessors (소규모: switch / 대규모: 직접 배열)");
        sb.AppendLine($"            Func<{fullTypeName}, object?>[] typedAccessors;");
        sb.AppendLine("            Func<object, object?>[] objectAccessors;");
        sb.AppendLine();
        sb.AppendLine("            if (__Expected <= __SmallThreshold)");
        sb.AppendLine("            {");
        sb.AppendLine($"                typedAccessors = new Func<{fullTypeName}, object?>[__Expected]");
        sb.AppendLine("                {");
        for (int i = 0; i < props.Count; i++)
            sb.AppendLine($"                    static dto => __GetTypedByOrdinal(in dto, {i}),");
        sb.AppendLine("                };");
        sb.AppendLine();
        sb.AppendLine("                objectAccessors = new Func<object, object?>[__Expected]");
        sb.AppendLine("                {");
        for (int i = 0; i < props.Count; i++)
            sb.AppendLine($"                    static obj => __GetObjectByOrdinal(obj, {i}),");
        sb.AppendLine("                };");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine($"                typedAccessors = new Func<{fullTypeName}, object?>[__Expected]");
        sb.AppendLine("                {");
        foreach (var p in props)
            sb.AppendLine($"                    static dto => dto.{p.Name},");
        sb.AppendLine("                };");
        sb.AppendLine();
        sb.AppendLine("                objectAccessors = new Func<object, object?>[__Expected]");
        sb.AppendLine("                {");
        foreach (var p in props)
            sb.AppendLine($"                    static obj => (({fullTypeName})obj).{p.Name},");
        sb.AppendLine("                };");
        sb.AppendLine("            }");

        // BufferAdder는 캐시 기반 __AddRow로 교체
        sb.AppendLine();
        sb.AppendLine("            // 4) BufferAdder (핫패스 최적화: 반복 캐스팅 제거)");
        sb.AppendLine($"            Action<{fullTypeName}, object[]> bufferAdder = __AddRow;");

        // SchemaTable / 반환
        sb.AppendLine();
        sb.AppendLine("            var schemaTable = TvpAccessors.BuildSchemaTable(propsInfo);");
        sb.AppendLine();
        sb.AppendLine($"            return new TvpAccessors<{fullTypeName}>");
        sb.AppendLine("            {");
        sb.AppendLine("                Properties = propsInfo,");
        sb.AppendLine("                Accessors = objectAccessors,");
        sb.AppendLine("                TypedAccessors = typedAccessors,");
        sb.AppendLine("                OrdinalMap = ordinal,");
        sb.AppendLine("                SchemaTable = schemaTable,");
        sb.AppendLine("                IsValidated = false,");
        sb.AppendLine($"                StaticValidator = new {validatorClassName}(),");
        sb.AppendLine("                BufferAdder = bufferAdder,");
        sb.AppendLine($"                SqlTypeName = {(sqlTypeName is null ? "null" : $"\"{sqlTypeName}\"")},");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine();

        // ArrayPool 기반 수집
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// 상속 계층 포함 인스턴스 PropertyInfo를 수집합니다. (ArrayPool 기반)");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        private static PropertyInfo[] GetAllInstancePropertiesPooled(Type t)");
        sb.AppendLine("        {");
        sb.AppendLine("            const BindingFlags Flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly;");
        sb.AppendLine("            var pool = ArrayPool<PropertyInfo>.Shared;");
        sb.AppendLine("            PropertyInfo[] buffer = pool.Rent(64);");
        sb.AppendLine("            int count = 0;");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                for (var cur = t; cur is not null && cur != typeof(object); cur = cur.BaseType)");
        sb.AppendLine("                {");
        sb.AppendLine("                    var arr = cur.GetProperties(Flags);");
        sb.AppendLine("                    if (arr.Length == 0) continue;");
        sb.AppendLine();
        sb.AppendLine("                    int need = count + arr.Length;");
        sb.AppendLine("                    if (need > buffer.Length)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        int newSize = Math.Max(buffer.Length * 2, need);");
        sb.AppendLine("                        var newBuf = pool.Rent(newSize);");
        sb.AppendLine("                        Array.Copy(buffer, 0, newBuf, 0, count);");
        sb.AppendLine("                        pool.Return(buffer, clearArray: true);");
        sb.AppendLine("                        buffer = newBuf;");
        sb.AppendLine("                    }");
        sb.AppendLine();
        sb.AppendLine("                    Array.Copy(arr, 0, buffer, count, arr.Length);");
        sb.AppendLine("                    count += arr.Length;");
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                var result = new PropertyInfo[count];");
        sb.AppendLine("                Array.Copy(buffer, 0, result, 0, count);");
        sb.AppendLine("                return result;");
        sb.AppendLine("            }");
        sb.AppendLine("            finally");
        sb.AppendLine("            {");
        sb.AppendLine("                pool.Return(buffer, clearArray: true);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        // MissingProperty
        sb.AppendLine("        [System.Diagnostics.CodeAnalysis.DoesNotReturn]");
        sb.AppendLine("        private static void ThrowMissingProperty(Type t, string name)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new InvalidOperationException($\"TVP 프로퍼티 메타데이터 조회 실패: 타입='{t.FullName}', 프로퍼티='{name}'\");");
        sb.AppendLine("        }");
        sb.AppendLine();

        // StaticValidator(기존 정책 유지: cols 변수 포함!)
        sb.AppendLine("        /// <summary>정적 스키마 검증기(스키마 불일치 조기 폭발).</summary>");
        sb.AppendLine($"        private sealed class {validatorClassName} : ITvpStaticValidator<{fullTypeName}>");
        sb.AppendLine("        {");
        sb.AppendLine("            public void ValidateStatic(TvpSchema schema)");
        sb.AppendLine("            {");
        sb.AppendLine("                var cols = schema.Columns;");
        sb.AppendLine($"                if (cols.Length != {props.Count})");
        sb.AppendLine("                    throw new TvpSchemaValidationException(schema.Name, \"스키마_컬럼수_불일치\",");
        sb.AppendLine($"                        $\"컬럼 수 불일치: 앱({props.Count}) != DB({{cols.Length}})\");");
        sb.AppendLine();

        for (int i = 0; i < props.Count; i++)
        {
            var p = props[i];

            // NOTE:
            // - 기존 코드가 사용하던 string.GetHashCode(StringComparison.OrdinalIgnoreCase) 정책 유지
            // - Hash 알고리즘이 바뀌면 런타임 계약이 바뀔 수 있으므로 보수적으로 “그대로 유지”합니다.
            var nameHash = string.GetHashCode(p.Name, StringComparison.OrdinalIgnoreCase);

            var expectedSqlType = GetSqlTypeFromSymbol(p.Type, useDatetime2);  // ✅ useDatetime2 전달

            sb.AppendLine($"                // Column [{i}]: {p.Name}");
            sb.AppendLine("                {");
            sb.AppendLine($"                    var col = cols[{i}];");
            sb.AppendLine($"                    if (col.NameHash != {nameHash})");
            sb.AppendLine("                        throw new TvpSchemaValidationException(schema.Name, \"컬럼명_불일치\",");
            sb.AppendLine($"                            $\"[{i}] 불일치: '{p.Name}' 기대됨 (실제 NameHash={{col.NameHash}})\", \"{p.Name}\", {i});");
            sb.AppendLine($"                    if (col.SqlDbType != SqlDbType.{expectedSqlType})");
            sb.AppendLine("                        throw new TvpSchemaValidationException(schema.Name, \"SQL타입_불일치\",");
            sb.AppendLine($"                            $\"[{i}] '{p.Name}': 앱({expectedSqlType}) != DB({{col.SqlDbType}})\", \"{p.Name}\", {i});");
            sb.AppendLine("                    if (col.IsIdentity)");
            sb.AppendLine("                        throw new TvpSchemaValidationException(schema.Name, \"ID/계산컬럼_쓰기금지\",");
            sb.AppendLine($"                            $\"[{i}] '{p.Name}': Identity 컬럼은 TVP에서 값을 제공할 수 없습니다.\", \"{p.Name}\", {i});");
            sb.AppendLine("                    if (col.IsComputed)");
            sb.AppendLine("                        throw new TvpSchemaValidationException(schema.Name, \"ID/계산컬럼_쓰기금지\",");
            sb.AppendLine($"                            $\"[{i}] '{p.Name}': Computed 컬럼은 TVP에서 값을 제공할 수 없습니다.\", \"{p.Name}\", {i});");
            sb.AppendLine("                }");
            sb.AppendLine();
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// [TvpRow]의 TypeName과 UseDatetime2 옵션 값을 읽어옵니다.
    /// </summary>
    /// <returns>Tuple: (SqlTypeName, UseDatetime2)</returns>
    private static (string? SqlTypeName, bool UseDatetime2) TryGetTvpRowOptions(INamedTypeSymbol typeSymbol)
    {
        foreach (var attr in typeSymbol.GetAttributes())
        {
            // AttributeMetadataName으로 찾는 계약은 "원본 유지"
            if (attr.AttributeClass?.ToDisplayString() != AttributeMetadataName)
                continue;

            string? typeName = null;
            bool useDatetime2 = false;

            foreach (var named in attr.NamedArguments)
            {
                if (named.Key == "TypeName" && named.Value.Value is string s)
                    typeName = s;
                else if (named.Key == "UseDatetime2" && named.Value.Value is bool b)
                    useDatetime2 = b;
            }

            return (typeName, useDatetime2);
        }

        return (null, false);
    }

    #endregion

    #region 타입 이름 표준화

    /// <summary>
    /// Roslyn 심볼을 “컴파일 안정적인 타입 문자열”로 변환합니다.
    /// <para>
    /// ✅ 생성 코드에 타입을 출력할 때는 반드시 이 함수를 사용하십시오.
    /// </para>
    /// </summary>
    private static string ToFullyQualifiedTypeName(ITypeSymbol type)
        => type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

    /// <summary>
    /// Nullable&lt;T&gt;라면 T를, 아니면 원래 타입을 반환합니다.
    /// <para>✅ TypeMappingRegistry로 위임</para>
    /// </summary>
    private static ITypeSymbol UnwrapNullable(ITypeSymbol type)
        => TypeMappingRegistry.UnwrapNullable(type);

    /// <summary>
    /// enum이면 underlying 타입을 반환합니다. 아니면 원래 타입을 반환합니다.
    /// <para>✅ TypeMappingRegistry로 위임</para>
    /// </summary>
    private static ITypeSymbol UnwrapEnumUnderlying(ITypeSymbol type)
        => TypeMappingRegistry.UnwrapEnumUnderlying(type);

    #endregion

    #region 도우미 메서드

    /// <summary>
    /// 속성 타입 심볼을 SQL Server SqlDbType 이름으로 매핑합니다.
    /// <para>
    /// ⚠️ TVP 스키마 검증(StaticValidator)에서 사용되므로
    /// 매핑 결과가 바뀌면 런타임 스키마 검증이 달라질 수 있습니다.
    /// </para>
    /// <para>✅ TypeMappingRegistry로 위임 (FullyQualified 기반 + DateTime2 옵션)</para>
    /// </summary>
    private static string GetSqlTypeFromSymbol(ITypeSymbol type, bool useDatetime2 = false)
        => TypeMappingRegistry.GetSqlDbTypeName(type, useDatetime2);

    /// <summary>
    /// TVP로 처리 가능한 Public 인스턴스 프로퍼티를 수집합니다.
    /// <para>
    /// 정책(원본 유지):
    /// <list type="bullet">
    /// <item><description>static 제외</description></item>
    /// <item><description>public만 허용</description></item>
    /// <item><description>getter 필요</description></item>
    /// <item><description>인덱서 제외(Parameters.Length==0)</description></item>
    /// </list>
    /// </para>
    /// </summary>
    private static List<IPropertySymbol> GetProcessableProperties(INamedTypeSymbol type)
    {
        var results = new List<IPropertySymbol>(32);
        var cur = type;

        while (cur is not null && cur.SpecialType != SpecialType.System_Object)
        {
            var props = cur.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p =>
                    !p.IsStatic &&
                    p.DeclaredAccessibility == Accessibility.Public &&
                    p.GetMethod is not null &&
                    p.Parameters.Length == 0);

            results.AddRange(props);
            cur = cur.BaseType;
        }

        // 결정론적 순서 보장(생성 코드 안정화)
        results.Sort(StableSymbolPropertyComparer.Instance);
        return results;
    }

    private sealed class StableSymbolPropertyComparer : IComparer<IPropertySymbol>
    {
        public static readonly StableSymbolPropertyComparer Instance = new();

        public int Compare(IPropertySymbol? a, IPropertySymbol? b)
            => StringComparer.Ordinal.Compare(a?.Name, b?.Name);
    }

    /// <summary>
    /// 생성 타입을 구분하기 위한 결정론적 suffix를 구성합니다.
    /// </summary>
    private static string GetUniqueSuffix(INamedTypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace
            ? ""
            : type.ContainingNamespace.ToDisplayString().Replace(".", "_");

        return string.IsNullOrEmpty(ns) ? type.Name : $"{ns}_{type.Name}";
    }

    /// <summary>
    /// 소스 제너레이터 AddSource에 사용될 “안전한 파일 힌트명”을 생성합니다.
    /// <para>완전 수식 이름 기반으로 생성하며, 파일명에 부적합한 문자를 치환합니다.</para>
    /// </summary>
    private static string BuildSafeHintName(INamedTypeSymbol type, string suffix)
    {
        var name = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_").Replace(">", "_")
            .Replace(".", "_")
            .Replace("+", "_");

        return name + suffix;
    }

    /// <summary>
    /// ASCII IgnoreCase FNV-1a 해시를 계산합니다.
    /// <para>해시 경로의 switch-case 키로 사용합니다(결정론적).</para>
    /// </summary>
    private static uint HashAsciiIgnoreCaseFnv1a(string s)
    {
        unchecked
        {
            const uint offset = 2166136261u;
            const uint prime = 16777619u;
            uint h = offset;

            for (int i = 0; i < s.Length; i++)
            {
                char c = s[i];
                if ((uint)(c - 'A') <= 25u) c = (char)(c | 0x20);
                h ^= c;
                h *= prime;
            }

            return h;
        }
    }

    #endregion
}

#endregion
