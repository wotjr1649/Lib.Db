// ============================================================================
// File: Lib.Db.TvpGen/ResultAccessorGenerator.cs
// Role: DbDataReader 결과를 DTO(class / record class)에 고성능(Track 5)으로 매핑하는
//       Result Accessor 코드를 생성하는 Source Generator
//
// ───────────────────────────────────────────────────────────────────────────
// ✅ 정책 확정본 (B-3 + CRITICAL-1~3) - "단일 파일" 고정 버전
// ---------------------------------------------------------------------------
// [B-3 타입 정책]
// 1) struct / record struct ❌ 완전 차단 (RES007)
// 2) class / record class ✅ 허용
// 3) new T() 생성 전략만 지원
//    - class: 매개변수 없는 생성자 필수 (RES004)
//    - record class: 기본 생성자 없으면(= positional record) ❌ 차단 (RES008)
//      (향후 "생성자 매핑" 도입 시 완화 가능)
// 4) 멤버 매핑 정책
//    - property: set/init 존재 시 허용 (init/non-public setter는 UnsafeAccessor로 주입)
//    - field:
//        * class  : 허용 (non-public field는 UnsafeAccessor로 주입)
//        * record : ❌ 금지 (불변성/무결성 보호) → 수집 단계에서 필드 제외로 "코드 강제"
// 5) Token 계약 유지 (스냅샷 테스트 안정성)
//    - 생성 파일 헤더 3줄 고정:
//      // <auto-generated/>
//      // TVPGEN:RESULT:TRACK5 (토큰)
//      // TVPGEN:ALGO_VERSION:... (토큰)
//
// [CRITICAL]
// CRITICAL-1) Ordinal 의미 고정: i는 DbDataReader ordinal이며, 모든 경로에서 ord = i로 통일
// CRITICAL-2) GetFieldValue<T>의 T는 항상 FullyQualifiedFormat 문자열로 강제
//            + Enum은 underlying 읽은 뒤 (EnumType) 캐스팅을 "반드시" 수행
// CRITICAL-3) partial 헤더는 원본 타입과 일치:
//            - record class → "partial record class"
//            - class        → "partial class"
//            (중첩 타입도 동일 규칙 적용)
// ───────────────────────────────────────────────────────────────────────────
// ✅ 안전 패치(추가) : IMapableResult 조건부 구현
// ---------------------------------------------------------------------------
// - 테스트(GeneratorTestHost)에서는 IMapableResult<T> 스텁이 존재하므로 implements를 붙여도 OK
// - 실 라이브러리/사용 환경에서 IMapableResult<T>가 없을 수 있으므로,
//   ▶ 심볼이 존재할 때만 ": IMapableResult<...>"를 붙이고
//   ▶ 없으면 implements 절을 생략하여 생성 코드가 컴파일 가능하도록 보장
//
//   ※ 이 패치는 “생성 코드의 컴파일 안정성”을 올리는 방어 로직이며,
//     토큰 계약/Track5/정책(B-3)/CRITICAL-1~3의 의미는 그대로 유지됩니다.
// ============================================================================


#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lib.Db.TvpGen;

#region [DB 결과 매핑 소스 제너레이터] ResultAccessorGenerator

/// <summary>
/// <para>
/// <b>[DbResult]</b> 특성이 선언된 DTO(class / record class)를 감지하여,
/// <see cref="System.Data.Common.DbDataReader"/> 결과를
/// 고성능(Span-Compare + FNV-1a Hash)으로 매핑하는 Accessor 코드를 자동 생성합니다.
/// </para>
/// <para>
/// ✅ 이 제너레이터의 목적은 “정책(Policy)과 구현(Implementation)”을 1:1로 고정하는 것입니다.
/// 즉, 주석만 정책이고 코드가 따라오지 않는 상태를 금지합니다.
/// </para>
/// <para>
/// ✅ 본 파일이 보장하는 것:
/// <list type="bullet">
/// <item><description><b>B-3 정책을 코드로 강제</b> (struct 차단, record 필드 금지, new T() 제약으로 positional record 차단)</description></item>
/// <item><description><b>중첩 타입(ContainingType)까지 partial 강제</b> (생성 코드가 중첩 partial 확장을 하기 때문)</description></item>
/// <item><description><b>Token 계약(헤더 3줄 고정)</b>으로 스냅샷 테스트를 “구현 디테일 변화”에 둔감하게 유지</description></item>
/// <item><description><b>Enum 캐스팅/완전 수식 타입</b>으로 컴파일 안정성 극대화</description></item>
/// </list>
/// </para>
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class ResultAccessorGenerator : IIncrementalGenerator
{
    #region [상수] Attribute/Interface 메타데이터 / 튜닝 파라미터

    /// <summary>DbResult Attribute의 메타데이터 전체 이름</summary>
    private const string AttributeMetadataName = "Lib.Db.Contracts.Mapping.DbResultAttribute";

    /// <summary>IMapableResult&lt;T&gt; 인터페이스의 메타데이터 전체 이름(제네릭 arity 포함)</summary>
    private const string IMapableResultMetadataName = "Lib.Db.Contracts.Mapping.IMapableResult`1";

    /// <summary>
    /// 하이브리드 라우팅 임계값
    /// <para>이 값 이하: 선형(else-if) / 초과: 해시(switch) 기반 라우팅</para>
    /// </summary>
    private const int SmallMemberThreshold = 12;

    #endregion

    #region [진단 메시지] Diagnostic Descriptors (한글화)

    private static readonly DiagnosticDescriptor RES001_PartialRequired =
         new(
             id: "RES001",
             title: "partial 키워드 필요",
             messageFormat: "타입 '{0}'은(는) [DbResult]를 지원하기 위해 반드시 'partial'로 선언되어야 합니다.",
             category: "Design",
             defaultSeverity: DiagnosticSeverity.Error,
             isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor RES002_GenericNotSupported =
        new(
            id: "RES002",
            title: "제네릭 타입 미지원",
            messageFormat: "[DbResult]는 제네릭 타입 정의 '{0}'에 사용할 수 없습니다.",
            category: "Design",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor RES003_InaccessibleType =
        new(
            id: "RES003",
            title: "접근 불가능한 타입",
            messageFormat: "타입 '{0}' 또는 상위 타입이 private/protected로 선언되어 있어 매핑 코드를 생성할 수 없습니다.",
            category: "Design",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor RES004_MissingParameterlessCtor =
        new(
            id: "RES004",
            title: "기본 생성자 필요",
            messageFormat: "타입 '{0}'은(는) 결과 매핑을 위해 매개변수가 없는 생성자가 필요합니다. (현재 생성 전략: new T())",
            category: "Design",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor RES005_NoMappableMembers =
        new(
            id: "RES005",
            title: "매핑 가능한 멤버 없음",
            messageFormat: "타입 '{0}'에 매핑 가능한 프로퍼티/필드가 없습니다. (Record는 필드 매핑이 제외됩니다).",
            category: "Design",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor RES006_DuplicateMemberName =
        new(
            id: "RES006",
            title: "중복된 멤버 이름",
            messageFormat: "타입 '{0}'에 멤버명 '{1}'이(가) 중복되어 매핑 코드를 생성할 수 없습니다.",
            category: "Design",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor RES007_OnlyRefTypeAllowed =
        new(
            id: "RES007",
            title: "값 타입(Struct) 미지원",
            messageFormat: "타입 '{0}'은(는) 값 타입(struct)입니다. 성능 안정성과 정책 일관성을 위해 class 또는 record(class)만 지원합니다.",
            category: "Design",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor RES008_RecordNotCreatable =
        new(
            id: "RES008",
            title: "record 생성 불가",
            messageFormat: "record 타입 '{0}'에 기본 생성자가 없습니다. (Primary Constructor 기반 positional record는 현재 new T() 생성 전략으로 매핑할 수 없습니다). 매개변수 없는 생성자를 추가하세요.",
            category: "Design",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    #endregion

    #region [초기화] 증분 파이프라인 구성 (IMapableResult 심볼 동반)

    /// <summary>
    /// Roslyn 증분 소스 생성기 파이프라인을 초기화합니다.
    /// <para>
    /// ✅ 안전 패치:
    /// <list type="bullet">
    /// <item><description><see cref="Compilation"/>을 함께 전달받아 IMapableResult&lt;T&gt; 심볼 존재 여부를 판단합니다.</description></item>
    /// <item><description>심볼이 있으면 implements를 생성 코드에 포함, 없으면 생략합니다.</description></item>
    /// </list>
    /// </para>
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeMetadataName,
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (ctx, _) => (INamedTypeSymbol)ctx.TargetSymbol)
            .WithComparer(SymbolEqualityComparer.Default);

        // ✅ Compilation + Types 를 결합해 Execute로 전달
        var combined = context.CompilationProvider.Combine(candidates.Collect());

        context.RegisterSourceOutput(
            combined,
            static (spc, pair) => Execute(spc, pair.Left, pair.Right));
    }

    #endregion

    #region [실행] 타입별 검증 및 코드 생성

    /// <summary>
    /// 후보 타입들에 대해 정책 검증을 수행하고,
    /// 통과한 타입만 Accessor 코드를 생성하여 출력합니다.
    /// </summary>
    private static void Execute(
        SourceProductionContext spc,
        Compilation compilation,
        ImmutableArray<INamedTypeSymbol> types)
    {
        if (types.IsDefaultOrEmpty)
            return;

        // ✅ IMapableResult<T> 심볼 존재 여부(테스트 스텁/실환경 차이 흡수)
        bool hasIMapableResult =
            compilation.GetTypeByMetadataName(IMapableResultMetadataName) is not null;

        var visited = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);


        foreach (var type in types)
        {
            spc.CancellationToken.ThrowIfCancellationRequested();

            if (type is null || !visited.Add(type))
                continue;

            // 1) 타입 검증 및 멤버 수집 (B-3안 정책 적용)
            if (!ValidateTypeAndCollectMembers(spc, type, out var members))
                continue;

            // 2) Track 5 엔진으로 소스 코드 생성 (✅ IMapableResult 조건부)
            var source = GenerateMapperSource(type, members, hasIMapableResult);

            // 3) 결과 파일 추가
            spc.AddSource(
                BuildSafeHintName(type, "_ResultAccessor.g.cs"),
                SourceText.From(source, Encoding.UTF8));
        }
    }

    #endregion

    #region [검증] 타입 유효성 검사 및 멤버 수집

    /// <summary>
    /// 타입이 [DbResult]를 사용하기에 적합한지 검사하고, 매핑할 멤버를 수집합니다.
    /// <para>
    /// 정책:
    /// <list type="number">
    /// <item><description>struct/record struct 차단</description></item>
    /// <item><description>제네릭 차단</description></item>
    /// <item><description>ContainingType 포함 접근성 검사</description></item>
    /// <item><description>ContainingType 포함 partial 검사(중첩 타입 포함)</description></item>
    /// <item><description>B-3 생성 전략(new T()) 기반: 기본 생성자 없으면 차단(Record는 RES008)</description></item>
    /// <item><description>record는 필드 매핑 금지</description></item>
    /// </list>
    /// </para>
    /// </summary>
    private static bool ValidateTypeAndCollectMembers(
        SourceProductionContext spc,
        INamedTypeSymbol type,
        out List<MappableMember> members)
    {
        members = new List<MappableMember>(32);

        // 1️⃣ struct / record struct 차단 (정책: 참조 타입 전용)
        if (type.TypeKind == TypeKind.Struct)
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                RES007_OnlyRefTypeAllowed,
                type.Locations.FirstOrDefault(),
                type.Name));
            return false;
        }

        // 2️⃣ 제네릭 금지
        if (type.IsGenericType)
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                RES002_GenericNotSupported,
                type.Locations.FirstOrDefault(),
                type.Name));
            return false;
        }

        // 3️⃣ 접근성 검사(ContainingType 포함)
        if (!IsAccessibleFromGeneratedCode(type))
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                RES003_InaccessibleType,
                type.Locations.FirstOrDefault(),
                type.Name));
            return false;
        }

        // 4️⃣ partial 검사(ContainingType 포함)  ✅ “ContainingType partial 검사” 강제
        if (!IsPartialIncludingContainingTypes(type))
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                RES001_PartialRequired,
                type.Locations.FirstOrDefault(),
                type.Name));
            return false;
        }

        // 5️⃣ 생성자 검증 (Record와 Class 분리 메시지)
        if (!HasParameterlessCtor(type))
        {
            var diag = type.IsRecord ? RES008_RecordNotCreatable : RES004_MissingParameterlessCtor;
            spc.ReportDiagnostic(Diagnostic.Create(diag, type.Locations.FirstOrDefault(), type.Name));
            return false;
        }

        // 6️⃣ 멤버 수집 (정책: Record는 필드 매핑 제외)
        members = CollectMappableMembers(type, isRecord: type.IsRecord);

        if (members.Count == 0)
        {
            spc.ReportDiagnostic(Diagnostic.Create(
                RES005_NoMappableMembers,
                type.Locations.FirstOrDefault(),
                type.Name));
            return false;
        }

        // 7️⃣ 중복 이름 검사 (대소문자 무시)
        var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var m in members)
        {
            if (!set.Add(m.Name))
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    RES006_DuplicateMemberName,
                    m.Location,
                    type.Name,
                    m.Name));
                return false;
            }
        }

        return true;
    }

    #endregion

    #region [수집] 멤버 수집 로직 class/record 정책 반영 (record 필드 금지)

    /// <summary>
    /// 매핑 가능한 멤버를 수집합니다.
    /// <para>
    /// 정책:
    /// <list type="bullet">
    /// <item><description>프로퍼티: set/init 존재 시 수집</description></item>
    /// <item><description>필드: record가 아닌 경우에만 수집 (✅ record 필드 매핑 금지)</description></item>
    /// </list>
    /// </para>
    /// </summary>
    private static List<MappableMember> CollectMappableMembers(INamedTypeSymbol type, bool isRecord)
    {
        var list = new List<MappableMember>(32);
        var cur = type;

        while (cur is not null && cur.SpecialType != SpecialType.System_Object)
        {
            // [프로퍼티]
            foreach (var p in cur.GetMembers().OfType<IPropertySymbol>())
            {
                if (p.IsStatic || p.IsIndexer)
                    continue;

                // set/init 없는 get-only 제외
                if (p.SetMethod is null)
                    continue;

                bool isPublicSet = p.SetMethod.DeclaredAccessibility == Accessibility.Public;
                bool isInitOnly = p.SetMethod.IsInitOnly;

                // init-only 또는 public이 아닌 setter는 UnsafeAccessor로 우회 주입
                bool requiresUnsafeSetter = isInitOnly || !isPublicSet;

                list.Add(new MappableMember(
                    Name: p.Name,
                    SafeName: SanitizeIdentifier(p.Name),
                    Type: p.Type,
                    Kind: MemberKind.Property,
                    RequiresUnsafeSetter: requiresUnsafeSetter,
                    RequiresUnsafeField: false,
                    Location: p.Locations.FirstOrDefault() ?? Location.None));
            }

            // [필드] ✅ record는 금지
            if (!isRecord)
            {
                foreach (var f in cur.GetMembers().OfType<IFieldSymbol>())
                {
                    if (f.IsStatic || f.IsConst || f.IsReadOnly)
                        continue;

                    bool requiresUnsafeField = f.DeclaredAccessibility != Accessibility.Public;

                    list.Add(new MappableMember(
                        Name: f.Name,
                        SafeName: SanitizeIdentifier(f.Name),
                        Type: f.Type,
                        Kind: MemberKind.Field,
                        RequiresUnsafeSetter: false,
                        RequiresUnsafeField: requiresUnsafeField,
                        Location: f.Locations.FirstOrDefault() ?? Location.None));
                }
            }

            cur = cur.BaseType;
        }

        // 결정론적 출력(스냅샷 안정화)
        list.Sort(static (a, b) => StringComparer.Ordinal.Compare(a.Name, b.Name));
        return list;
    }

    #endregion

    #region [CodeGen] 매핑 코드 생성 (CRITICAL-1~3 + IMapableResult 조건부)

    /// <summary>
    /// Track 5 엔진(Span 비교 + FNV-1a)을 적용하여 매핑 소스를 생성합니다.
    /// <para>
    /// ✅ CRITICAL-1: Ordinal 의미 고정(항상 DbDataReader ordinal i 사용, 경로 간 의미 불일치 제거)
    /// </para>
    /// <para>
    /// ✅ CRITICAL-2: GetFieldValue&lt;T&gt;의 T는 “완전 수식(FullyQualified)” 타입 문자열로 강제
    /// </para>
    /// <para>
    /// ✅ CRITICAL-3: record/class 헤더를 정확히 생성(Partial 확장 시 record는 partial record class)
    /// </para>
    /// <para>
    /// ✅ 안전 패치: IMapableResult&lt;T&gt; 심볼이 있을 때만 implements 절을 생성
    /// </para>
    /// </summary>
    private static string GenerateMapperSource(
        INamedTypeSymbol type,
        List<MappableMember> members,
        bool hasIMapableResult)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToDisplayString();
        var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // 중첩 타입(바깥 → 안쪽) 래핑
        var containers = GetContainingTypesOuterToInner(type);

        var sb = new StringBuilder(128 * 1024);

        // [스냅샷 토큰 계약] 3줄 고정
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// " + TvpGenFeatureTokens.ResultTrack5);
        sb.AppendLine("// " + TvpGenFeatureTokens.AlgoVersion);
        sb.AppendLine("#nullable enable");

        // using (생성 코드 컴파일 최소 세트)
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Data.Common;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Microsoft.Data.SqlClient;");
        sb.AppendLine();

        if (hasIMapableResult)
        {
            // 존재할 때만 using/implements 의미가 있음
            sb.AppendLine("using Lib.Db.Contracts.Mapping;");
            sb.AppendLine();
        }

        if (ns is not null)
        {
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
        }

        // 중첩 타입 래핑(바깥 → 안쪽)
        foreach (var ct in containers)
        {
            sb.Append("    ").AppendLine(BuildPartialTypeHeader(ct));
            sb.AppendLine("    {");
        }

        var indent = new string(' ', 4 + containers.Count * 4);

        // ✅ IMapableResult 조건부 implements
        var implementsClause = hasIMapableResult
            ? $" : global::Lib.Db.Contracts.Mapping.IMapableResult<{fullName}>"
            : string.Empty;

        sb.Append(indent).AppendLine($"{BuildPartialTypeHeader(type)}{implementsClause}");
        sb.Append(indent).AppendLine("{");

        // 1) FNV-1a Hash (ASCII ignore-case)
        sb.AppendLine();
        sb.Append(indent).AppendLine("    #region [내부 해시] 결정론적 이름 해시(FNV-1a, ASCII IgnoreCase)");
        sb.Append(indent).AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        sb.Append(indent).AppendLine("    private static uint __HashName(ReadOnlySpan<char> s)");
        sb.Append(indent).AppendLine("    {");
        sb.Append(indent).AppendLine("        unchecked");
        sb.Append(indent).AppendLine("        {");
        sb.Append(indent).AppendLine("            const uint offset = 2166136261u;");
        sb.Append(indent).AppendLine("            const uint prime = 16777619u;");
        sb.Append(indent).AppendLine("            uint h = offset;");
        sb.Append(indent).AppendLine("            for (int i = 0; i < s.Length; i++)");
        sb.Append(indent).AppendLine("            {");
        sb.Append(indent).AppendLine("                char c = s[i];");
        sb.Append(indent).AppendLine("                if ((uint)(c - 'A') <= 25u) c = (char)(c | 0x20);");
        sb.Append(indent).AppendLine("                h ^= c;");
        sb.Append(indent).AppendLine("                h *= prime;");
        sb.Append(indent).AppendLine("            }");
        sb.Append(indent).AppendLine("            return h;");
        sb.Append(indent).AppendLine("        }");
        sb.Append(indent).AppendLine("    }");
        sb.Append(indent).AppendLine("    #endregion");
        sb.AppendLine();

        // 2) Unrolled ASCII matcher
        sb.Append(indent).AppendLine("    #region [내부 비교] 멤버별 ASCII IgnoreCase(언롤) 매칭 함수");
        foreach (var m in members)
        {
            sb.Append(GenerateUnrolledAsciiMatch(indent + "    ", m));
            sb.AppendLine();
        }
        sb.Append(indent).AppendLine("    #endregion");
        sb.AppendLine();

        // 3) UnsafeAccessor 정의
        sb.Append(indent).AppendLine("    #region [UnsafeAccessor] init-only / non-public setter / non-public field 지원");
        foreach (var m in members)
        {
            var tName = m.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            if (m.Kind == MemberKind.Property && m.RequiresUnsafeSetter)
            {
                sb.Append(indent).AppendLine($"    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = \"set_{m.Name}\")]");
                sb.Append(indent).AppendLine($"    private static extern void __Set_{m.SafeName}({fullName} target, {tName} value);");
                sb.AppendLine();
            }
            else if (m.Kind == MemberKind.Field && m.RequiresUnsafeField)
            {
                sb.Append(indent).AppendLine($"    [UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"{m.Name}\")]");
                sb.Append(indent).AppendLine($"    private static extern ref {tName} __Field_{m.SafeName}({fullName} target);");
                sb.AppendLine();
            }
        }
        sb.Append(indent).AppendLine("    #endregion");
        sb.AppendLine();

        // 4) CreateParser
        sb.Append(indent).AppendLine("    /// <summary>");
        sb.Append(indent).AppendLine("    /// DbDataReader 컬럼 정보로부터 고성능 매핑 델리게이트를 생성합니다.");
        sb.Append(indent).AppendLine("    /// <para>Ordinal 결정은 1회 수행되며, 반환 델리게이트는 ord 값을 캡처합니다.</para>");
        sb.Append(indent).AppendLine("    /// </summary>");
        sb.Append(indent).AppendLine($"    public static Func<DbDataReader, {fullName}> CreateParser(DbDataReader reader)");
        sb.Append(indent).AppendLine("    {");

        foreach (var m in members)
            sb.Append(indent).AppendLine($"        int ord_{m.SafeName} = -1;");

        sb.AppendLine();
        sb.Append(indent).AppendLine($"        int __expected = {members.Count};");
        sb.Append(indent).AppendLine("        int __remaining = __expected;");
        sb.AppendLine();

        sb.Append(indent).AppendLine($"        if (__expected <= {SmallMemberThreshold})");
        sb.Append(indent).AppendLine("        {");
        sb.Append(indent).AppendLine("            for (int i = 0; i < reader.FieldCount; i++)");
        sb.Append(indent).AppendLine("            {");
        sb.Append(indent).AppendLine("                var span = reader.GetName(i).AsSpan();");

        for (int i = 0; i < members.Count; i++)
        {
            var m = members[i];
            var head = (i == 0) ? "                if" : "                else if";
            sb.Append(indent).AppendLine($"{head} (ord_{m.SafeName} == -1 && __Match_{m.SafeName}(span))");
            sb.Append(indent).AppendLine("                {");
            sb.Append(indent).AppendLine($"                    ord_{m.SafeName} = i;");
            sb.Append(indent).AppendLine("                    if (--__remaining == 0) break;");
            sb.Append(indent).AppendLine("                }");
        }

        sb.Append(indent).AppendLine("            }");
        sb.Append(indent).AppendLine("        }");
        sb.Append(indent).AppendLine("        else");
        sb.Append(indent).AppendLine("        {");
        sb.Append(indent).AppendLine("            for (int i = 0; i < reader.FieldCount; i++)");
        sb.Append(indent).AppendLine("            {");
        sb.Append(indent).AppendLine("                var span = reader.GetName(i).AsSpan();");
        sb.Append(indent).AppendLine("                uint h = __HashName(span);");
        sb.Append(indent).AppendLine("                switch (h)");
        sb.Append(indent).AppendLine("                {");

        foreach (var m in members)
        {
            uint hash = HashAsciiIgnoreCaseFnv1a(m.Name);
            sb.Append(indent).AppendLine($"                    case 0x{hash:X8}u: // {m.Name}");
            sb.Append(indent).AppendLine($"                        if (ord_{m.SafeName} == -1 && __Match_{m.SafeName}(span))");
            sb.Append(indent).AppendLine("                        {");
            sb.Append(indent).AppendLine($"                            ord_{m.SafeName} = i;");
            sb.Append(indent).AppendLine("                            if (--__remaining == 0) goto __done;");
            sb.Append(indent).AppendLine("                        }");
            sb.Append(indent).AppendLine("                        break;");
        }

        sb.Append(indent).AppendLine("                    default: break;");
        sb.Append(indent).AppendLine("                }");
        sb.Append(indent).AppendLine("            }");
        sb.Append(indent).AppendLine("        }");
        sb.AppendLine();
        sb.Append(indent).AppendLine("        __done:;");

        // 매핑 람다(new T() 전략)
        sb.AppendLine();
        sb.Append(indent).AppendLine("        return r =>");
        sb.Append(indent).AppendLine("        {");
        sb.Append(indent).AppendLine($"            var result = new {fullName}();");

        foreach (var m in members)
        {
            var expr = GetReaderValueExpression(m.Type, $"ord_{m.SafeName}");

            sb.Append(indent).AppendLine($"            if (ord_{m.SafeName} != -1 && !r.IsDBNull(ord_{m.SafeName}))");
            sb.Append(indent).AppendLine("            {");

            if (m.Kind == MemberKind.Property)
            {
                if (m.RequiresUnsafeSetter)
                    sb.Append(indent).AppendLine($"                __Set_{m.SafeName}(result, {expr});");
                else
                    sb.Append(indent).AppendLine($"                result.{m.Name} = {expr};");
            }
            else
            {
                if (m.RequiresUnsafeField)
                    sb.Append(indent).AppendLine($"                __Field_{m.SafeName}(result) = {expr};");
                else
                    sb.Append(indent).AppendLine($"                result.{m.Name} = {expr};");
            }

            sb.Append(indent).AppendLine("            }");
        }

        sb.Append(indent).AppendLine("            return result;");
        sb.Append(indent).AppendLine("        };");

        sb.Append(indent).AppendLine("    }"); // CreateParser end
        sb.AppendLine();

        // Map 메서드 (테스트 스텁 계약 충족; 실환경에선 사용하지 않아도 컴파일만 되면 OK)
        sb.Append(indent).AppendLine($"    public static {fullName} Map(SqlDataReader reader) => CreateParser(reader)(reader);");

        sb.Append(indent).AppendLine("}"); // type end

        // containers close
        for (int i = containers.Count - 1; i >= 0; i--)
        {
            sb.Append(' ', 4 + (i * 4)).AppendLine("}");
        }

        if (ns is not null)
            sb.AppendLine("}");

        return sb.ToString();
    }

    #endregion

    #region [보조 생성기] 언롤 매칭 함수 생성

    private static string GenerateUnrolledAsciiMatch(string indent, MappableMember m)
    {
        var lower = ToAsciiLowerInvariant(m.Name);
        int len = lower.Length;

        var sb = new StringBuilder(512);
        sb.Append(indent).AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        sb.Append(indent).AppendLine($"private static bool __Match_{m.SafeName}(ReadOnlySpan<char> s)");
        sb.Append(indent).AppendLine("{");
        sb.Append(indent).AppendLine($"    if (s.Length != {len}) return false;");

        for (int i = 0; i < len; i++)
        {
            char expected = lower[i];

            sb.Append(indent).AppendLine($"    char c{i} = s[{i}];");
            sb.Append(indent).AppendLine($"    if ((uint)(c{i} - 'A') <= 25u) c{i} = (char)(c{i} | 0x20);");
            sb.Append(indent).AppendLine($"    if (c{i} != '{EscapeCharForCharLiteral(expected)}') return false;");
        }

        sb.Append(indent).AppendLine("    return true;");
        sb.Append(indent).AppendLine("}");
        return sb.ToString();
    }

    private static string ToAsciiLowerInvariant(string s)
    {
        var chars = s.ToCharArray();
        for (int i = 0; i < chars.Length; i++)
        {
            char c = chars[i];
            if ((uint)(c - 'A') <= 25u) chars[i] = (char)(c | 0x20);
        }
        return new string(chars);
    }

    private static string EscapeCharForCharLiteral(char c)
        => c switch
        {
            '\\' => "\\\\",
            '\'' => "\\'",
            '\0' => "\\0",
            '\n' => "\\n",
            '\r' => "\\r",
            '\t' => "\\t",
            _ => c.ToString()
        };

    #endregion

    #region [Reader 값 읽기] 타입별 최적화 + Enum 캐스팅 + FullyQualified 강제 (CRITICAL-2)

    /// <summary>
    /// DbDataReader에서 값을 읽는 표현식을 생성합니다.
    /// <para>
    /// ✅ 원칙:
    /// <list type="bullet">
    /// <item><description>기본형: GetInt32/GetString 등 전용 API 사용</description></item>
    /// <item><description>Enum: underlying 값을 읽은 뒤 (EnumType) 캐스팅</description></item>
    /// <item><description>기타: GetFieldValue&lt;T&gt; 사용 (T는 FullyQualifiedFormat으로 고정)</item></list>
    /// </para>
    /// <para>✅ TypeMappingRegistry로 위임</para>
    /// </summary>
    private static string GetReaderValueExpression(ITypeSymbol typeSymbol, string ordVar)
        => TypeMappingRegistry.GetReaderValueExpression(typeSymbol, ordVar);

    #endregion

    #region [Helpers] 중첩 타입/partial 헤더/접근성/partial/힌트명/해시

    private static bool HasParameterlessCtor(INamedTypeSymbol type)
        => type.Constructors.Any(c => !c.IsStatic && c.Parameters.Length == 0);

    private static bool IsAccessibleFromGeneratedCode(INamedTypeSymbol type)
    {
        var cur = type;
        while (cur is not null)
        {
            if (cur.DeclaredAccessibility is Accessibility.Private or Accessibility.Protected)
                return false;

            cur = cur.ContainingType;
        }
        return true;
    }

    /// <summary>
    /// ✅ “ContainingType partial 검사” 포함:
    /// <para>
    /// 대상 타입이 partial이어도, 바깥(ContainingType)이 partial이 아니면
    /// 생성 코드에서 동일한 형태로 확장( partial class Outer { partial class Inner ... } )이 불가능합니다.
    /// </para>
    /// </summary>
    private static bool IsPartialIncludingContainingTypes(INamedTypeSymbol type)
    {
        // 본인 + 모든 ContainingType이 partial이어야 함
        for (INamedTypeSymbol? cur = type; cur is not null; cur = cur.ContainingType)
        {
            if (!IsPartial(cur))
                return false;
        }
        return true;
    }

    private static bool IsPartial(INamedTypeSymbol type)
    {
        foreach (var syntaxRef in type.DeclaringSyntaxReferences)
        {
            if (syntaxRef.GetSyntax() is TypeDeclarationSyntax s &&
                s.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                return true;
        }
        return false;
    }

    private static List<INamedTypeSymbol> GetContainingTypesOuterToInner(INamedTypeSymbol type)
    {
        var stack = new Stack<INamedTypeSymbol>();
        var cur = type.ContainingType;
        while (cur is not null)
        {
            stack.Push(cur);
            cur = cur.ContainingType;
        }
        return stack.ToList();
    }

    /// <summary>
    /// ✅ CRITICAL-3: record 타입은 반드시 "partial record class" 형태로 확장해야 합니다.
    /// </summary>
    private static string BuildPartialTypeHeader(INamedTypeSymbol t)
    {
        if (t.IsRecord)
            return $"partial record class {t.Name}";

        return $"partial class {t.Name}";
    }

    private static string BuildSafeHintName(INamedTypeSymbol type, string suffix)
    {
        var name = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_").Replace(">", "_")
            .Replace(".", "_")
            .Replace("+", "_");
        return name + suffix;
    }

    private static string SanitizeIdentifier(string s)
    {
        if (string.IsNullOrEmpty(s))
            return "_";

        var sb = new StringBuilder(s.Length + 1);

        char first = s[0];
        if (!(char.IsLetter(first) || first == '_'))
            sb.Append('_');

        foreach (var ch in s)
        {
            if (char.IsLetterOrDigit(ch) || ch == '_') sb.Append(ch);
            else sb.Append('_');
        }

        return sb.ToString();
    }

    private static uint HashAsciiIgnoreCaseFnv1a(string s)
    {
        unchecked
        {
            const uint offset = 2166136261u;
            const uint prime = 16777619u;
            uint h = offset;
            for (int i = 0; i < s.Length; i++)
            {
                char c = s[i];
                if ((uint)(c - 'A') <= 25u) c = (char)(c | 0x20);
                h ^= c;
                h *= prime;
            }
            return h;
        }
    }

    #endregion

    #region [내부 모델] MappableMember

    private enum MemberKind { Property, Field }

    /// <summary>
    /// 매핑 대상 멤버(프로퍼티/필드) 정보
    /// </summary>
    private readonly record struct MappableMember(
            string Name,
            string SafeName,
            ITypeSymbol Type,
            MemberKind Kind,
            bool RequiresUnsafeSetter,
            bool RequiresUnsafeField,
            Location Location);

    #endregion
}

#endregion
