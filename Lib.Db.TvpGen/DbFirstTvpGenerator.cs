using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lib.Db.TvpGen;

/// <summary>
/// 디자인 타임 스키마(libdb.schema.json)를 읽어 TVP DTO 코드를 자동 생성하는 제너레이터
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DbFirstTvpGenerator : IIncrementalGenerator
{
    private const string AttributeMetadataName = "Lib.Db.Contracts.Models.GenerateTvpFromDbAttribute";
    private const string SchemaFileName = "libdb.schema.json";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. [GenerateTvpFromDb]가 붙은 클래스 찾기
        var classes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeMetadataName,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => (INamedTypeSymbol)ctx.TargetSymbol)
            .WithComparer(SymbolEqualityComparer.Default);

        // 2. AdditionalFiles에서 libdb.schema.json 찾기
        var schemaFile = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith(SchemaFileName, StringComparison.OrdinalIgnoreCase))
            .Select(static (file, cancellationToken) => file.GetText(cancellationToken)?.ToString())
            .Where(static text => text is not null)
            .Collect()
            .Select(static (texts, _) => texts.FirstOrDefault()); // 첫 번째 파일만 사용

        // 3. 결합 및 실행
        var source = classes.Collect().Combine(schemaFile);

        context.RegisterSourceOutput(source, Execute);
    }

    private static void Execute(SourceProductionContext spc, (ImmutableArray<INamedTypeSymbol> Classes, string? SchemaJson) input)
    {
        var (classes, json) = input;
        if (classes.IsDefaultOrEmpty) return;
        if (string.IsNullOrEmpty(json)) return;

        // JSON 파싱 (MiniParser)
        var schema = MiniJsonParser.Parse(json!);
        if (schema == null) return;

        foreach (var classSymbol in classes)
        {
            var options = GetAttributeOptions(classSymbol);
            if (options.TvpName is null) continue;

            if (schema.Tvps.TryGetValue(options.TvpName, out var columns))
            {
                var code = GenerateClass(classSymbol, columns, options.UsePascalCase);
                spc.AddSource($"{classSymbol.Name}.Generated.cs", SourceText.From(code, Encoding.UTF8));
            }
            else
            {
                // 경고: 스키마를 찾을 수 없음
                // spc.ReportDiagnostic(...);
            }
        }
    }

    private static (string? TvpName, bool UsePascalCase) GetAttributeOptions(INamedTypeSymbol symbol)
    {
        var attr = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttributeMetadataName);

        if (attr == null) return (null, true);

        string? name = attr.ConstructorArguments.FirstOrDefault().Value as string;
        bool usePascal = true;

        foreach (var named in attr.NamedArguments)
        {
            if (named.Key == "UsePascalCase" && named.Value.Value is bool b)
                usePascal = b;
        }

        return (name, usePascal);
    }

    private static string GenerateClass(INamedTypeSymbol symbol, List<ColumnDef> columns, bool usePascal)
    {
        var ns = symbol.ContainingNamespace.ToDisplayString();
        var className = symbol.Name;
        var modifiers = symbol.DeclaredAccessibility.ToString().ToLowerInvariant(); 
        if (modifiers == "internal") modifiers = "internal"; // Roslyn enum to string conversion simple check
        else modifiers = "public"; // Force public or check symbol.DeclaredAccessibility explicitly if strictly needed

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
        sb.AppendLine("using Lib.Db.Contracts.Models;"); // TvpRowAttribute
        sb.AppendLine();
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// DB 스키마 기반 자동 생성 TVP DTO");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    [TvpRow(TypeName = \"{columns[0].TvpName}\")] // 메타데이터 주입");
        sb.AppendLine($"    public partial class {className}");
        sb.AppendLine("    {");

        foreach (var col in columns)
        {
            var propName = usePascal ? ToPascalCase(col.Name) : col.Name;
            var typeName = MapSqlTypeToCSharp(col.Type);
            
            sb.AppendLine("        /// <summary>");
            sb.AppendLine($"        /// {col.Name} ({col.Type})");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine($"        public {typeName} {propName} {{ get; set; }}");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string ToPascalCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToUpperInvariant(name[0]) + name.Substring(1);
    }

    private static string MapSqlTypeToCSharp(string sqlType)
    {
        return sqlType.ToLowerInvariant() switch
        {
            "bigint" => "long",
            "int" => "int",
            "smallint" => "short",
            "tinyint" => "byte",
            "bit" => "bool",
            "decimal" or "numeric" or "money" => "decimal",
            "float" => "double",
            "real" => "float",
            "datetime" or "datetime2" or "date" => "DateTime",
            "datetimeoffset" => "DateTimeOffset",
            "varchar" or "nvarchar" or "char" or "nchar" or "text" or "ntext" => "string",
            "uniqueidentifier" => "Guid",
            "binary" or "varbinary" or "image" => "byte[]",
            _ => "object"
        };
    }
}

// --- 별도 파일로 분리해도 되지만 편의상 내부에 포함 (Private Helpers) ---

internal class SchemaRoot
{
    public Dictionary<string, List<ColumnDef>> Tvps { get; set; } = new();
}

internal class ColumnDef
{
    public string Name { get; set; } = "";
    public string Type { get; set; } = "";
    // 파서 편의를 위해 임시 저장
    public string TvpName { get; set; } = ""; 
}

internal static class MiniJsonParser
{
    // 정규식 기반의 매우 초보적인 파서 (의존성 제거 목표)
    // 실제 프로덕션 레벨에서는 System.Text.Json(SourceGen) 또는 더 견고한 파서를 권장하나
    // 현재 제약상 "libdb.schema.json"의 정해진 포맷만 파싱함.
    public static SchemaRoot? Parse(string json)
    {
        try
        {
            var root = new SchemaRoot();
            // "Tvps": { ... } 찾기
            // 복잡한 중첩 파싱 대신, 정규식으로 "Key": [Array] 패턴을 찾습니다.
            // 1. "Tvps" 블록 추출
            var tvpsIndex = json.IndexOf("\"Tvps\"", StringComparison.OrdinalIgnoreCase);
            if (tvpsIndex < 0) return null;

            var braceOpen = json.IndexOf('{', tvpsIndex);
            var content = json.Substring(braceOpen); // 대략적인 내용

            // 매우 단순화된 파싱: 각 TVP 키와 배열 블록을 찾음
            // 예: "dbo.User": [ ... ]
            // 정규식: "([^"]+)"\s*:\s*\[([^\]]+)\]
            // 주의: 중첩 객체 처리에 한계가 있음.

            // 대안: 문자열을 한 글자씩 읽는 State Machine Parser (안전함)
            return PoorMansStateMachine(json);
        }
        catch
        {
            return null;
        }
    }

    private static SchemaRoot PoorMansStateMachine(string json)
    {
        var root = new SchemaRoot();
        
        // 퀵 앤 더티: 그냥 문자열 검색으로 "dbo.XXX" 키와 그 내부 객체들을 찾는다.
        // 하지만 신뢰성을 위해 Step-by-step 파싱을 흉내냅니다.
        
        // 실제 구현은 시간 관계상 "간단한 가정"에 의존합니다.
        // 가정: JSON은 Pretty Print 또는 표준 포맷을 따른다.
        
        // 1. Tvps 섹션 찾기
        var tvpSection = System.Text.RegularExpressions.Regex.Match(json, "\"Tvps\"\\s*:\\s*\\{");
        if (!tvpSection.Success) return root;

        int startIndex = tvpSection.Index + tvpSection.Length;
        
        // 2. 각 Key 찾기 ("Key": [ ... ])
        // 닫는 중괄호 } 를 만날 때까지 반복
        // 단순 정규식으로 "키": [ ... ] 를 추출합니다. (Non-greedy)
        var matches = System.Text.RegularExpressions.Regex.Matches(json.Substring(startIndex), "\"([^\"]+)\"\\s*:\\s*\\[(.*?)\\]", System.Text.RegularExpressions.RegexOptions.Singleline);

        foreach (System.Text.RegularExpressions.Match m in matches)
        {
            var tvpName = m.Groups[1].Value;
            var arrayContent = m.Groups[2].Value;

            var cols = ParseColumns(arrayContent);
            foreach(var c in cols) c.TvpName = tvpName;
            root.Tvps[tvpName] = cols;
        }

        return root;
    }

    private static List<ColumnDef> ParseColumns(string arrayContent)
    {
        var list = new List<ColumnDef>();
        // { "Name": "A", "Type": "B" } 패턴 반복
        var matches = System.Text.RegularExpressions.Regex.Matches(arrayContent, "\\{(.*?)\\}", System.Text.RegularExpressions.RegexOptions.Singleline);

        foreach (System.Text.RegularExpressions.Match m in matches)
        {
            var objContent = m.Groups[1].Value;
            var col = new ColumnDef();
            
            // "Name": "Value" 찾기
            var props = System.Text.RegularExpressions.Regex.Matches(objContent, "\"([^\"]+)\"\\s*:\\s*\"([^\"]+)\"");
            foreach (System.Text.RegularExpressions.Match p in props)
            {
                var k = p.Groups[1].Value;
                var v = p.Groups[2].Value;
                
                if (k == "Name") col.Name = v;
                else if (k == "Type") col.Type = v;
            }
            if(!string.IsNullOrEmpty(col.Name))
                list.Add(col);
        }
        return list;
    }
}
