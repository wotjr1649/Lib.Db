# Lib.Db.TvpGen 개선 구현 계획

**목표**: TypeMappingRegistry 도입으로 정책 단일화, FullyQualified 타입 판별 전환, DateTime2 옵션화, 테스트 커버리지 강화

**분석 프레임워크**: Sequential Thinking + Context7 (Roslyn/SQL Server 최신 문서)

---

## User Review Required

> [!IMPORTANT]
> **DateTime2 옵션 기본값**
> - 기본값: `useDatetime2: false` (기존 DateTime 유지)
> - SQL Server 2008+ 권장: DateTime2 (더 넓은 범위, 높은 정밀도)
> - 기존 TVP 스키마와의 호환성을 위해 기본값 false로 설정
> - 옵션 활성화: `[TvpRow(UseDatetime2 = true)]` 또는 생성 시 매개변수

> [!WARNING] 
> **Breaking Change 가능성**
> - TypeMappingRegistry 도입으로 내부 로직 변경
> - 하지만 토큰 계약(TVPGEN:TVP:TRACK5, TVPGEN:ALGO:2025-12-18) 유지로 기존 테스트 안정성 보장
> - 생성 코드의 동작은 동일 (FullyQualified 전환은 컴파일 안정성만 향상)

---

## Proposed Changes

### Phase 1: TypeMappingRegistry 도입 + FullyQualified 전환

#### [NEW] [TypeMappingRegistry.cs](file:///c:/Users/js/Documents/BOWOO/20251217/Lib.Db/Lib.Db.TvpGen/TypeMappingRegistry.cs)

**역할**: C# ↔ SQL Server 타입 매핑의 단일 진실 원천 (Single Source of Truth)

**주요 기능**:
1. `GetSqlDbTypeName(ITypeSymbol, bool useDatetime2)`: C# → SQL Server 매핑
   - FullyQualified 기반 타입 판별 (`global::System.Guid` 등)
   - DateTime2 옵션 지원
   - Nullable/Enum unwrap 통합

2. `GetReaderValueExpression(ITypeSymbol, string ordVar)`: DbDataReader API 선택
   - 기본형: GetInt32/GetString 전용 API
   - Enum: underlying 읽고 캐스팅
   - 기타: GetFieldValue<T> (T는 FullyQualified)

3. 헬퍼 메서드:
   - `UnwrapNullable(ITypeSymbol)`: Nullable<T> → T
   - `UnwrapEnumUnderlying(ITypeSymbol)`: Enum → underlying type

**변경 내용**:
```csharp
// 기존 (type.Name 기반, 충돌 가능)
_ => type.Name switch
{
    "Guid" => "UniqueIdentifier",
    "DateTimeOffset" => "DateTimeOffset",
    // ...
}

// 개선 (FullyQualified 기반, 안전)
var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
return fullName switch
{
    "global::System.Guid" => "UniqueIdentifier",
    "global::System.DateTimeOffset" => "DateTimeOffset",
    // ...
}
```

**DateTime2 옵션**:
```csharp
private static bool TryGetSpecialTypeSqlName(SpecialType specialType, bool useDatetime2, out string sqlName)
{
    sqlName = specialType switch
    {
        // ...
        SpecialType.System_DateTime => useDatetime2 ? "DateTime2" : "DateTime",
        // ...
    };
    return sqlName is not null;
}
```

---

### Phase 2: TvpGenFeatureTokens 확장

#### [MODIFY] [TvpGenFeatureTokens.cs](file:///c:/Users/js/Documents/BOWOO/20251217/Lib.Db/Lib.Db.TvpGen/TvpGenFeatureTokens.cs)

**변경 사항**:
```csharp
public static class TvpGenFeatureTokens
{
    public const string ResultTrack5 = "TVPGEN:RESULT:TRACK5";
    public const string TvpTrack5 = "TVPGEN:TVP:TRACK5";
    public const string AlgoVersion = "TVPGEN:ALGO:2025-12-18";
    
    // ✅ NEW: DateTime2 사용 여부 토큰
    public const string DateTimeTypeToken = "TVPGEN:DATETIME_TYPE";
    
    /// <summary>
    /// DateTime2 사용 시 헤더에 추가될 토큰
    /// </summary>
    public static string GetDateTimeToken(bool useDatetime2)
        => $"{DateTimeTypeToken}:{(useDatetime2 ? "DateTime2" : "DateTime")}";
}
```

**이유**: 
- 스냅샷 테스트 안정성 유지
- DateTime vs DateTime2 사용 여부를 토큰으로 명시
- 테스트에서 DateTime2 옵션 검증 가능

---

### Phase 3: 제너레이터 리팩토링

#### [MODIFY] [TvpAccessorGenerator.cs](file:///c:/Users/js/Documents/BOWOO/20251217/Lib.Db/Lib.Db.TvpGen/TvpAccessorGenerator.cs)

**변경 1**: TypeMappingRegistry 사용

```csharp
// 기존 (732-814행 제거)
private static string ToFullyQualifiedTypeName(ITypeSymbol type) { ... }
private static ITypeSymbol UnwrapNullable(ITypeSymbol type) { ... }
private static ITypeSymbol UnwrapEnumUnderlying(ITypeSymbol type) { ... }
private static string GetSqlTypeFromSymbol(ITypeSymbol type) { ... }

// 개선
private static string ToFullyQualifiedTypeName(ITypeSymbol type)
    => type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

private static string GetSqlTypeFromSymbol(ITypeSymbol type, bool useDatetime2 = false)
    => TypeMappingRegistry.GetSqlDbTypeName(type, useDatetime2);
```

**변경 2**: DateTime2 옵션 처리

```csharp
// TryGetSqlTypeName 확장하여 UseDatetime2 속성 읽기
private static (string? SqlTypeName, bool UseDatetime2) TryGetTvpRowOptions(INamedTypeSymbol typeSymbol)
{
    foreach (var attr in typeSymbol.GetAttributes())
    {
        if (attr.AttributeClass?.ToDisplayString() != AttributeMetadataName)
            continue;

        string? typeName = null;
        bool useDatetime2 = false;

        foreach (var named in attr.NamedArguments)
        {
            if (named.Key == "TypeName" && named.Value.Value is string s)
                typeName = s;
            else if (named.Key == "UseDatetime2" && named.Value.Value is bool b)
                useDatetime2 = b;
        }

        return (typeName, useDatetime2);
    }

    return (null, false);
}
```

**변경 3**: 헤더 토큰에 DateTime 타입 추가

```csharp
// GenerateRegistrationCode에서
sb.AppendLine("// <auto-generated/>");
sb.AppendLine("// " + TvpGenFeatureTokens.TvpTrack5);
sb.AppendLine("// " + TvpGenFeatureTokens.AlgoVersion);
sb.AppendLine("// " + TvpGenFeatureTokens.GetDateTimeToken(useDatetime2)); // ✅ NEW
sb.AppendLine("#nullable enable");
```

---

#### [MODIFY] [ResultAccessorGenerator.cs](file:///c:/Users/js/Documents/BOWOO/20251217/Lib.Db/Lib.Db.TvpGen/ResultAccessorGenerator.cs)

**변경 1**: TypeMappingRegistry 사용

```csharp
// 기존 (737-803행 제거)
private static string GetReaderValueExpression(ITypeSymbol typeSymbol, string ordVar) { ... }
private static string GetPrimitiveReadExpr(...) { ... }

// 개선
private static string GetReaderValueExpression(ITypeSymbol typeSymbol, string ordVar)
    => TypeMappingRegistry.GetReaderValueExpression(typeSymbol, ordVar);
```

**변경 2**: 헤더 토큰 (DateTime 타입은 ResultAccessor에서는 불필요, TVP만 적용)

---

### Phase 4: 테스트 커버리지 강화

#### [MODIFY] [TvpAccessorGeneratorContractTests.cs](file:///c:/Users/js/Documents/BOWOO/20251217/Lib.Db/Lib.Db.TvpGen.Tests/TvpAccessorGeneratorContractTests.cs)

**추가 테스트 1**: type.Name 충돌 방지 검증

```csharp
[Fact]
public async Task TypeName충돌_사용자정의Guid_차단()
{
    var code = @"
using Lib.Db.Contracts.Models;

namespace TestNamespace;

// 사용자 정의 Guid 클래스 (BCL과 충돌)
public class Guid
{
    public string Value { get; set; } = """";
}

[TvpRow]
public class TestDto
{
    public {|#0:Guid|} CustomGuid { get; set; } = default!;
}";
    // 기대: TVP004 (지원되지 않는 타입)
    // 이유: FullyQualified 기반이므로 global::TestNamespace.Guid로 인식, Variant 반환
    var expected = new DiagnosticResult("TVP004", DiagnosticSeverity.Error)
        .WithLocation(0)
        .WithArguments("CustomGuid", "global::TestNamespace.Guid");

    await GeneratorTestHost.VerifyTvpDiagnosticsAsync(new[] { code }, expected);
}
```

**추가 테스트 2**: DateTime2 옵션 검증

```csharp
[Fact]
public async Task DateTime2_옵션_활성화()
{
    var code = @"
using Lib.Db.Contracts.Models;
using System;

namespace TestNamespace;

[TvpRow(TypeName=""dbo.T_Event"", UseDatetime2 = true)]
public class EventRow
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; }
}";
    var generated = await GeneratorTestHost.RunTvpGeneratorAndGetGeneratedSourcesAsync(code);

    // 헤더 토큰 검증
    GeneratorTestHost.MustContainAny(generated,
        "TVPGEN:TVP:TRACK5",
        "TVPGEN:DATETIME_TYPE:DateTime2");
    
    // StaticValidator에서 DateTime2 검증
    GeneratorTestHost.MustContainAny(generated, "SqlDbType.DateTime2");
}

[Fact]
public async Task DateTime_기본값_유지()
{
    var code = @"
using Lib.Db.Contracts.Models;
using System;

namespace TestNamespace;

[TvpRow(TypeName=""dbo.T_Event"")]
public class EventRow
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; }
}";
    var generated = await GeneratorTestHost.RunTvpGeneratorAndGetGeneratedSourcesAsync(code);

    // 기본값은 DateTime (호환성 유지)
    GeneratorTestHost.MustContainAny(generated,
        "TVPGEN:DATETIME_TYPE:DateTime");
    
    // StaticValidator에서 DateTime 검증
    GeneratorTestHost.MustContainAny(generated, "SqlDbType.DateTime");
}
```

**추가 테스트 3**: .NET 10 신규 타입 검증

```csharp
[Fact]
public async Task Net10_DateOnly_TimeOnly_Half_지원()
{
    var code = @"
using Lib.Db.Contracts.Models;
using System;

namespace TestNamespace;

[TvpRow]
public class Net10Types
{
    public DateOnly BirthDate { get; set; }
    public TimeOnly StartTime { get; set; }
    public Half Temperature { get; set; }
}";
    var generated = await GeneratorTestHost.RunTvpGeneratorAndGetGeneratedSourcesAsync(code);

    GeneratorTestHost.MustContainAny(generated, "TVPGEN:TVP:TRACK5");
    // StaticValidator에서 Date, Time, Real 매핑 확인
    GeneratorTestHost.MustContainAny(generated, "SqlDbType.Date");
    GeneratorTestHost.MustContainAny(generated, "SqlDbType.Time");
    GeneratorTestHost.MustContainAny(generated, "SqlDbType.Real");
}
```

---

#### [MODIFY] [ResultAccessorGeneratorContractTests.cs](file:///c:/Users/js/Documents/BOWOO/20251217/Lib.Db/Lib.Db.TvpGen.Tests/ResultAccessorGeneratorContractTests.cs)

**추가 테스트 4**: record struct 차단 검증

```csharp
[Fact]
public async Task RES007_RecordStruct_차단()
{
    var code = @"
using Lib.Db.Contracts.Mapping;

namespace TestNamespace;

[DbResult]
public partial record struct {|#0:MyRecordStruct|}(int Id, string Name);
";
    var expected = new DiagnosticResult("RES007", DiagnosticSeverity.Error)
        .WithLocation(0)
        .WithArguments("MyRecordStruct");

    await GeneratorTestHost.VerifyResultDiagnosticsAsync(new[] { code }, expected);
}
```

**추가 테스트 5**: positional record 차단 검증

```csharp
[Fact]
public async Task RES008_PositionalRecord_차단()
{
    var code = @"
using Lib.Db.Contracts.Mapping;

namespace TestNamespace;

[DbResult]
public partial record {|#0:MyPositionalRecord|}(int Id, string Name);
// ↑ 기본 생성자 없음 (Primary Constructor만 존재)
";
    var expected = new DiagnosticResult("RES008", DiagnosticSeverity.Error)
        .WithLocation(0)
        .WithArguments("MyPositionalRecord");

    await GeneratorTestHost.VerifyResultDiagnosticsAsync(new[] { code }, expected);
}
```

**추가 테스트 6**: non-public field UnsafeAccessor 검증

```csharp
[Fact]
public async Task NonPublicField_UnsafeAccessor_생성()
{
    var code = @"
using Lib.Db.Contracts.Mapping;

namespace TestNamespace;

[DbResult]
public partial class MyDto
{
    public required int Id { get; set; }
    private string _internalCache = """"; // ← private field
}";
    var generated = await GeneratorTestHost.RunResultGeneratorAndGetGeneratedSourcesAsync(code);

    // UnsafeAccessor 생성 확인
    GeneratorTestHost.MustContainAny(generated, 
        "[UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"_internalCache\")]");
}
```

**추가 테스트 7**: Enum 처리 검증

```csharp
[Fact]
public async Task Enum_UnderlyingType_캐스팅()
{
    var code = @"
using Lib.Db.Contracts.Mapping;

namespace TestNamespace;

public enum Status : short
{
    Active = 1,
    Inactive = 0
}

[DbResult]
public partial class MyDto
{
    public required int Id { get; set; }
    public required Status Status { get; set; }
}";
    var generated = await GeneratorTestHost.RunResultGeneratorAndGetGeneratedSourcesAsync(code);

    // Enum 캐스팅 확인: (Status)r.GetInt16(ord)
    GeneratorTestHost.MustContainAny(generated, "GetInt16");
    GeneratorTestHost.MustContainAny(generated, "global::TestNamespace.Status");
}
```

**추가 테스트 8**: 중첩 타입 partial 검증

```csharp
[Fact]
public async Task 중첩타입_Partial_검증()
{
    var code = @"
using Lib.Db.Contracts.Mapping;

namespace TestNamespace;

public partial class Outer
{
    [DbResult]
    public partial class {|#0:Inner|}
    {
        public required int Id { get; set; }
    }
}";
    var generated = await GeneratorTestHost.RunResultGeneratorAndGetGeneratedSourcesAsync(code);

    // 중첩 partial 생성 확인
    GeneratorTestHost.MustContainAny(generated, "partial class Outer");
    GeneratorTestHost.MustContainAny(generated, "partial class Inner");
}
```

**추가 테스트 9**: FullyQualified 타입 안정성

```csharp
[Fact]
public async Task FullyQualified_타입_안정성()
{
    var code = @"
using Lib.Db.Contracts.Mapping;
using System;

namespace TestNamespace;

[DbResult]
public partial class MyDto
{
    public required Guid Id { get; set; }
    public required DateTimeOffset CreatedAt { get; set; }
}";
    var generated = await GeneratorTestHost.RunResultGeneratorAndGetGeneratedSourcesAsync(code);

    // FullyQualified 타입 사용 확인
    GeneratorTestHost.MustContainAny(generated, "global::System.Guid");
    GeneratorTestHost.MustContainAny(generated, "global::System.DateTimeOffset");
}
```

**추가 테스트 10**: Track5 최적화 임계값

```csharp
[Fact]
public async Task Track5_소규모_ElseIf_경로()
{
    // 12개 이하: else-if 체인
    var code = @"
using Lib.Db.Contracts.Mapping;

namespace TestNamespace;

[DbResult]
public partial class SmallDto
{
    public required int P1 { get; set; }
    public required int P2 { get; set; }
    // ... P12까지
}";
    var generated = await GeneratorTestHost.RunResultGeneratorAndGetGeneratedSourcesAsync(code);

    // else-if 경로 확인 (SmallMemberThreshold 이하)
    GeneratorTestHost.MustContainAny(generated, "if (__expected <= ");
}

[Fact]
public async Task Track5_대규모_Hash_경로()
{
    // 13개 이상: FNV-1a + switch
    var code = @"
using Lib.Db.Contracts.Mapping;

namespace TestNamespace;

[DbResult]
public partial class LargeDto
{
    public required int P1 { get; set; }
    // ... P13까지
}";
    var generated = await GeneratorTestHost.RunResultGeneratorAndGetGeneratedSourcesAsync(code);

    // hash 경로 확인
    GeneratorTestHost.MustContainAny(generated, "uint h = __HashName");
}
```

---

## Verification Plan

### Automated Tests

#### Test 1: TypeMappingRegistry 단위 테스트
```powershell
# 새 테스트 파일 생성: Lib.Db.TvpGen.Tests/TypeMappingRegistryTests.cs
dotnet test --filter "FullyQualifiedName~TypeMappingRegistryTests"
```

**검증 항목**:
- Nullable unwrap 정확성
- Enum unwrap 정확성
- FullyQualified 기반 타입 판별 (type.Name 충돌 방지)
- DateTime vs DateTime2 옵션 동작
- .NET 10 신규 타입 (DateOnly, TimeOnly, Half)

#### Test 2: 기존 계약 테스트 (토큰 기반)
```powershell
dotnet test --filter "FullyQualifiedName~ContractTests"
```

**기대 결과**: 
- 모든 기존 테스트 통과 (토큰 계약으로 보호됨)
- 헤더 3줄 유지: `<auto-generated/>`, `TVPGEN:*:TRACK5`, `TVPGEN:ALGO:2025-12-18`

#### Test 3: 신규 엣지 케이스 테스트
```powershell
dotnet test --filter "DisplayName~type.Name충돌"
dotnet test --filter "DisplayName~DateTime2"
dotnet test --filter "DisplayName~RecordStruct"
dotnet test --filter "DisplayName~PositionalRecord"
```

#### Test 4: 전체 테스트 실행
```powershell
cd c:\Users\js\Documents\BOWOO\20251217\Lib.Db\Lib.Db.TvpGen.Tests
dotnet test --logger "console;verbosity=detailed"
```

### Manual Verification

#### Verification 1: 생성 코드 검증

1. 샘플 DTO 작성:
```csharp
using Lib.Db.Contracts.Models;
using System;

// DateTime2 옵션 활성화
[TvpRow(TypeName="dbo.T_Event", UseDatetime2 = true)]
public class EventRow
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; }
    public Guid CorrelationId { get; set; }
    public DateOnly EventDate { get; set; }
}
```

2. 생성 코드 확인:
   - `obj/Debug/net10.0/generated/` 디렉토리 확인
   - 헤더 토큰: `TVPGEN:DATETIME_TYPE:DateTime2`
   - StaticValidator: `SqlDbType.DateTime2`
   - FullyQualified 타입: `global::System.Guid`, `global::System.DateOnly`

#### Verification 2: SQL Server 스키마 검증

```sql
-- DateTime2 사용 TVP 생성
CREATE TYPE dbo.T_Event AS TABLE
(
    Id INT,
    CreatedAt DATETIME2,  -- ← DateTime2
    CorrelationId UNIQUEIDENTIFIER,
    EventDate DATE
);

-- TVP 사용
CREATE PROCEDURE dbo.PR_Insert_Events
    @Events dbo.T_Event READONLY
AS
BEGIN
    -- ...
END;
```

#### Verification 3: 런타임 검증

```csharp
// Lib.Db 사용 테스트
var events = new[]
{
    new EventRow
    {
        Id = 1,
        CreatedAt = DateTime.UtcNow,  // DateTime2 정밀도 유지
        CorrelationId = Guid.NewGuid(),
        EventDate = DateOnly.FromDateTime(DateTime.Today)
    }
};

await session.From("dbo.PR_Insert_Events")
    .WithTvpParameter("@Events", events)
    .ExecuteAsync();
```

---

## Implementation Order

### Step 1: TypeMappingRegistry 구현 ✅ **COMPLETED** (Priority 1)
- [x] `Lib.Db.TvpGen/TypeMappingRegistry.cs` 생성 (256줄)
- [x] UnwrapNullable, UnwrapEnumUnderlying 구현
- [x] GetSqlDbTypeName (FullyQualified + DateTime2 옵션)
- [x] GetReaderValueExpression 구현

### Step 2: TvpGenFeatureTokens 확장 ✅ **COMPLETED** (Priority 1)
- [x] DateTime 타입 토큰 추가
- [x] GetDateTimeToken 헬퍼 추가

### Step 3: TvpAccessorGenerator 리팩토링 ✅ **COMPLETED** (Priority 2)
- [x] TypeMappingRegistry 사용으로 전환
- [x] TryGetTvpRowOptions 확장 (UseDatetime2)
- [x] 헤더 토큰에 DateTime 타입 추가
- [x] 기존 UnwrapNullable 등 제거

### Step 4: ResultAccessorGenerator 리팩토링 ✅ **COMPLETED** (Priority 2)
- [x] TypeMappingRegistry 사용으로 전환
- [x] GetReaderValueExpression 제거 (~67줄 중복 제거)

### Step 5: 테스트 강화 ⏳ **IN PROGRESS** (Priority 3)

#### 완료된 테스트:
- [x] 기존 테스트 수정 (record struct RES007, TVP004 FullyQualified)
- [x] 모든 기존 테스트 통과 확인 (20/20 ✅)

#### 신규 테스트 추가 예정 (10개):
- [ ] **TvpAccessor 테스트 (3개)**:
  1. [ ] type.Name 충돌 방지 (사용자 정의 Guid vs BCL)
  2. [ ] DateTime2 옵션 활성화 검증
  3. [ ] DateTime 기본값 유지 검증

- [ ] **ResultAccessor 테스트 (7개)**:
  4. [ ] .NET 10 신규 타입 (DateOnly, TimeOnly, Half)
  5. [ ] UnsafeAccessor non-public field
  6. [ ] Enum underlying 캐스팅
  7. [ ] 중첩 타입 partial
  8. [ ] FullyQualified 타입 안정성
  9. [ ] Track5 소규모 (≤12) else-if 경로
  10. [ ] Track5 대규모 (>12) hash 경로

### Step 6: 검증 및 문서화 ⏳ **PENDING** (Priority 4)
- [x] 전체 테스트 실행 (ALL GREEN 달성: 20/20)
- [x] 생성 코드 검수 (FullyQualified, DateTime2 토큰 확인)
- [ ] 마이그레이션 가이드 작성
- [ ] Developer Guide 업데이트 (DateTime2 사용법)
- [ ] 성능 벤치마크 (선택)

---

## Risk Mitigation

### Risk 1: DateTime2 변경으로 인한 스키마 불일치

**완화 전략**:
- 기본값 `DateTime` 유지 (호환성)
- 옵션 명시적 활성화 필요 (`UseDatetime2 = true`)
- StaticValidator가 런타임에 스키마 검증

### Risk 2: FullyQualified 전환으로 인한 코드 변화

**완화 전략**:
- 토큰 계약으로 테스트 안정성 보장
- 생성 코드 동작은 100% 동일 (타입 표기만 변경)
- 기존 테스트 모두 통과 예상

### Risk 3: TypeMappingRegistry 도입으로 인한 빌드 실패

**완화 전략**:
- 단계별 구현 (파일 생성 → 제너레이터 통합)
- 각 단계 후 빌드 확인
- 롤백 가능 (Git 커밋 단위)

---

## Success Criteria

✅ **ALL GREEN**: 모든 기존 테스트 통과  
✅ **10+ NEW TESTS**: 엣지 케이스 테스트 10개 이상 추가  
✅ **TOKEN CONTRACT**: 토큰 계약 유지 (TVPGEN:TVP:TRACK5, TVPGEN:ALGO:2025-12-18)  
✅ **DATETIME2 OPTION**: DateTime2 옵션 정상 동작  
✅ **FULLYQUALIFIED**: type.Name 충돌 방지  
✅ **CODE REVIEW**: 생성 코드 품질 검증  
✅ **DOCUMENTATION**: 마이그레이션 가이드 작성  

---

## Next Steps After Implementation

1. **성능 벤치마크**: Track5 최적화 효과 측정
2. **실환경 적용**: Lib.Db 프로젝트에서 DateTime2 옵션 테스트
3. **추가 타입 지원**: Int128, UInt128 (SQL Server Decimal 매핑)
4. **Analyzer 도입**: 모범 사례 검증 (선택 사항)
